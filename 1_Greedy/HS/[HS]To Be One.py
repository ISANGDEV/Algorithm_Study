"""문제
어떠한 수 N이 1이 될 때 까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다.
이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다.

N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오.
🎁입력 조건
첫째줄에 N(2 <= N < = 100000)과 K(2 <= K < = 100000)가 공백으로 구분되며 각각 자연수로 주어진다.
🎊출력 조건
첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다 """

# N과 K 모두 2보다 클 때 1 빼는것보다 나누는게 감소 값이 큼.  2 -1 = 2 / 2   |  3 - 1 > 3/2   k가 가장 작은 수 여도, n이 2만 아니면 나누는게 더 작아짐
#그럼 최소로 1을 만들려면 "많이" 나눠야 함. 나누기 위해서는 N = X * K가 성립 해야 함. X는 자연수임. 이 경우 최소 횟수는 나눈 횟수
# 만약 초기 조건에서 나누어 떨어지지 않음 => N = X * K + Y. 그럼 Y만큼 빼고 X번 나누면 됨. 이 경우 최소 횟수는  나눈 횟수 + 1만큼 뺀 횟수(Y)

n, k = map(int, input("n과 k 입력").split())  # n 과 K 입력 받음
cnt = 0
# tmp = 0
while (n != 1 and n >= k): # n이 1이 될 때 까지, n이 k보다 클 때 까지
    if n % k == 0: # 나눌 수 있으면
        n = n / k # 나누고
        cnt = cnt + 1 # 연산 횟수 더하고
    else: # 나눌 수 없으면
        cnt = cnt + n % k # 1. 미리 뺄 횟수를 더해주고(나머지를 더해주고) 2.이렇게 하면 tmp 변수 없어도 됨.
        #tmp = n % k
        n = n - (n%k) # 그 다음에 나머지를 빼 줘서 n이 k로 나누어 떨어지게 바꾸고.
        # cnt = cnt + tmp

if (n < k): #만약 한번에 안 나눠지고 n이 k보다 작아졌으면 1씩 빼야 함.
    cnt = cnt + (n -1) # 빼는 횟수


print(cnt)
